
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>gonefuture</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="缓存持久化系统学习概述common-ramcache是一个用于缓存和持久化的组件，可以随Spring一起工作。 注解@Retentiion(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Cache {      /** 缓存管理类型 */     CacheType type() default Cache">
<meta property="og:type" content="article">
<meta property="og:title" content="gonefuture">
<meta property="og:url" content="http://gonefuture.top/2019/11/13/项目笔记/缓存持久化系统学习/index.html">
<meta property="og:site_name" content="gonefuture">
<meta property="og:description" content="缓存持久化系统学习概述common-ramcache是一个用于缓存和持久化的组件，可以随Spring一起工作。 注解@Retentiion(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Cache {      /** 缓存管理类型 */     CacheType type() default Cache">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-12-06T07:34:41.874Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gonefuture">
<meta name="twitter:description" content="缓存持久化系统学习概述common-ramcache是一个用于缓存和持久化的组件，可以随Spring一起工作。 注解@Retentiion(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Cache {      /** 缓存管理类型 */     CacheType type() default Cache">
  
    <link rel="alternative" href="/atom.xml" title="gonefuture" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/gonefutre"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">钱伟健的个人博客</a>
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">gonefuture</li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/categories">categories</a>
      
        <a class="main-nav-link" href="/tags">tags</a>
      
        <a class="main-nav-link" href="/about">about</a>
      
      <a class="main-nav-link st-search-show-outputs">Search</a>
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-项目笔记/缓存持久化系统学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2019/11/13/项目笔记/缓存持久化系统学习/" class="article-date">
  <time datetime="2019-11-13T07:22:14.988Z" itemprop="datePublished">2019-11-13</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h1 id="缓存持久化系统学习"><a href="#缓存持久化系统学习" class="headerlink" title="缓存持久化系统学习"></a>缓存持久化系统学习</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>common-ramcache</code>是一个用于缓存和持久化的组件，可以随Spring一起工作。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><pre><code class="java">@Retentiion(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Cache {

    /** 缓存管理类型 */
    CacheType type() default CacheType.LRU;

    /** 缓存单位 */
    CacheUnit unit() default CacheUnit.ENTITY;

}
</code></pre>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化处理器接口</p>
<pre><code class="java">public interface Presister {
    // 初始化方法
    void initialize();
    // 将指定元素插入此队列中
    void put(Element element);
    // 添加监听器
    void addListener(Class&lt;? extends AbstractEntity&gt; clz, Listenrt listener);
    // 获取监听器
    Listener getListener(Class&lt;? extends AbstractEntity&gt; clz, Listener listener);
    // 停止更新队列并等待全部入库完成
    void shutdown();

    // 获取当前的状态信息
    Map&lt;String, String&gt; getInfo();

}

</code></pre>
<p>队列更新结果监听器</p>
<pre><code class="java">public abstract class AbstractListener implements Listener {
    // 队列更新的回调
    void notify(EventType type, boolean isSuccesss, Serializable id, AbstractEntity entity, RuntimeException ex);
}
</code></pre>
<p>抽象监听器用于简化监听器的开发</p>
<pre><code class="java">public abstract class AbstractListener implements Listener {

    @Override
    public void notify() {
        try {
            if(isSuccess) {
                switch(type) {
                    case INSERT:
                        onSaveSuccess(id, entity);
                        break;
                    case UPDATE:
                        onUpdateSuccess(entity);
                        break;
                    case DELETE:
                        onRemoveSuccess(id);
                        break;
                    deafault: 
                        logger.error(&quot;未支持的更新事件类型[{}]&quot;, type);
                }
            } else {
                switch(type) {
                    case INSERT:
                        onSeveError(id, entity, ex);
                        break;
                    case UPDATE:
                        onUpdateError(entity, ex);
                        break;
                    case DELETE:
                        onRemoveError(id, ex);
                        break;
                }
            }
        } catch (Exception e) {
            logger.error(&quot;队列监听器[{}]处理出现异常&quot;, new Obeject[] {this.getClass().getName(), e});
        }
    }

    // 实体保存成功时的回调，需要则覆盖
    protected void onSaveSuccess(Serializable id, AbstractEntity entity) {

    }

    // 实体更新成功时的回调，需要则覆盖
    protected void onUpdateSuccess(AbstractEntity entity) {

    }
    // 实体删除成功的回调，需要则覆盖
    protected void onRemoveSuccess(Serializable id) {

    }
    // 实体保存失败时的回调，需要则覆盖
    protected void onSaveError(Serializable id, AbstractEntity entity, RuntimeException ex) {

    }
    // 实体更新失败时的回调，则需要覆盖
    protected onUpdateError(AbstractEntity entity, RuntimeException ex) {

    }
    // 实体更新失败时的回调，则需要覆盖
    protected onUpdateError(AbstractEntity entity, RuntimeException ex) {

    }
    // 实体删除失败时的回调，需要则覆盖
    protected void onRemoveError(Serializable id, RuntimeException ex) {

    }
}

</code></pre>
<p>实体更新事件类型定义</p>
<pre><code class="java">public enum EventType {
    // 插入
    INSERT,
    // 更新
    UPDATE，
    // 删除
    DELETE;
}

队列元素

```java
public class Element {

    // 构造插入元素
    public static Elment saveOf(AbstractEntity entity) {
        return new Element(EventType.INSERT, entity.getId(), entity, entity.getClass());
    }

   // 构造删除元素
    public static Element removeOf(Serializable id, Class&lt;? extends AbstractEntity entityClass&gt;) {
        return new Element(EventType.DELETE, id, null, entityClass);
    }

    // 构造更新元素
    public static Element updateOf(AbstractEntity entity) {
        return new Element(EventType.UPDATE, entity.getId(), entity);
    }

    // 事件类型（不为null）
    private EventType type;
    // 实体主键（不为null）
    private final Serializable id;
    // 实体实例（删除时会为null）
    private AbstractEntity entity;
    // 实体类型（不会为null）
    private final Class&lt;? extends AbstractEntity&gt; entityClass;

    // 构造方法
    private Element(EventType type, Serializable id, AbstractEntity entity, Class&lt;? extends AbstractEntity&gt; entityClass) {
        this.type = type;
        this.id = id;
        this.entity = entity;
        this.entityClass = entityClass;
    }

    // 获取标识
    public String getIdentity() {
        return entiyClass.getName() + &quot;:&quot; + id;
    }

    // 更新队列元素的状态
    // 该方法不假设更新元素是同一个元素，因此元素判断要在使用该方法前处理
    // true: 需要保留 . fale:
    public boolean update(Element element) {
        entity = elemnt.getEntity();
        switch(type) {
            // 之前的状态为SAVE
            case INSERT:
                switch(element.getType()) {
                    // 当前的状态
                    case INSERT:
                        logger.error(&quot;更新元素异常，实体[{}]原状态[{}]当前状态[{}]不进行修改&quot;，getIdentity(), type, elment.getType());
                        break;
                    case UPDATE:
                        if(logger.isDebgEnabled()) {
                            logger.error(&quot;实体[{}]原状态[{}]当前状态[{}]修正后状态[{}]是否保留队列元素[{}]&quot;，getIdentity(),EventType.INSERT, elment.getType()
                        }
                        break;
                    case DELETE:
                        if(logger.isDebugenabled()) {
                            logger.error(&quot;实体[{}]原状态[{}]当前状态[{}]不进行修改&quot;，getIdentity(), type, elment.getType());
                        }
                    return false;
                    default :
                }
                break;
                // 之前的状态为UPDATE
                case UPDATE:
                    switch(element.getType()) {
                       case INSERT:
                        logger.error(&quot;更新元素异常，实体[{}]原状态[{}]当前状态[{}]不进行修改&quot;，getIdentity(), type, elment.getType());
                        break;
                    case UPDATE:
                        if(logger.isDebgEnabled()) {
                            logger.error(&quot;实体[{}]原状态[{}]当前状态[{}]修正后状态[{}]是否保留队列元素[{}]&quot;，getIdentity(),, elment.getType());
                        }
                        break;
                    case DELETE:
                        if(logger.isDebugenabled()) {
                            logger.error(&quot;实体[{}]原状态[{}]当前状态[{}]不进行修改&quot;，getIdentity(), type, elment.getType());
                        }
                        break;
                        default : 
                    } 
                case DELETE:
                    switch(element.getType()) {
                       case INSERT:
                        logger.error(&quot;更新元素异常，实体[{}]原状态[{}]当前状态[{}]不进行修改&quot;，getIdentity(), type, elment.getType());
                        break;
                        case UPDATE:
                            if(logger.isDebgEnabled()) {
                                logger.error(&quot;实体[{}]原状态[{}]当前状态[{}]修正后状态[{}]是否保留队列元素[{}]&quot;，getIdentity(),, elment.getType());
                            }
                            break;
                        case DELETE:
                            if(logger.isDebugenabled()) {
                                logger.error(&quot;实体[{}]原状态[{}]当前状态[{}]不进行修改&quot;，getIdentity(), type, elment.getType());
                            }
                            break;
                            default :
                    }
                    break;
                default:
                }
            return true;
    }


    // Getter anf  Setter...
}
</code></pre>
<p>定时持久化处理器。该持久化处理器会以CRON表达指定的时间进行入库操作，未达到入库时间点的持久化操作会进行累计并去重</p>
<pre><code class="java">public class TimingPersister implements Presister {

    // 正在等待更新的信息缓存
    private ConcurrentHashMap&lt;String, Element&gt; elements = new ConcurrentHashMap&lt;&gt;();
    // 对应实体的处理监听器
    private ConcurrentHashMap&lt;Class&lt;? extends AbstractEntity&gt;, Listener&gt; listeners = new ConcurrentHashMap&lt;&gt;();
    // 初始化标识
    private boolean initialize;
    // 初始化
    private TimingConsumer consumer;

    // 实现接口的方法

    // 初始化方法
    @OVerride
    public synchronized void initialize(String name, Accessor, String period) {
        if(initialize) {
            throw new ConfigurationException(&quot;重复初始化异常&quot;);
        }
        Assert.notNull(accessor, &quot;持久层数据访问器不能为 null&quot;);
        try {
            this.elements = new ConcurrentHashMap&lt;&gt;();
            this.consumer = new TimingConsumer(name, period, accessor, this);
            initiallize = true;
        } catch (Exception e) {
            throw new ConfigurationException(&quot;定时持久化处理器[&quot;+name+&quot;]初始化失败&quot;+e.getMessage());
        }
    }

    // 添加监听器
    @Override
    public void addListener(Class&lt;? extends AbstractEntity&gt; clz, Listenrt listener) {
        if(listener == null) {
            throw new ConfigurationException(&quot;被添加的监听器实例不能未空&quot;);
        }
        listenner.put(clz,listener);
    }
    // 获取监听器
    public Listener getListener(Class&lt;? extends AbstractEntity&gt; clz) {
        return listeners.get(clz);
    }
    // 指定元素插入此队列中，将等待可用的空间（如果有必要）
    @Override
    public void put(Element element) {
        if(element == null) {
            return;
        }
        if(stop) {
            FormattingTuple message = MessageFormatter.format(&quot;实体更新队列已经停止，更新元素[{}]将不被接受&quot;,element);
            logger.error(message.getMessage());
            throw new StateException(message.getMessage());
        }
    }
    String id = elment.getIdentity();
    rwLock.readLock().lock();
    Lock lock = lockIdLock(id);
    try {
        Element prev = elements.get(id);
        // 更新元素不存在的场景
        if(perv == null) {
            eleement.put(id, element);
            return;
        }
        // 更新元素已经存在的场景
        EventType prevType = prev.getType();
        if(！prev.update(elemnt)) {
            elements.remove(id);
        } else {
            // 当从REMOVE合并为UPDATE的时候要让监听器通知缓存服务将内部的临时失效主键清除
            if(prevType == EventType.DELETE &amp;&amp; prev.getType() == EventType.UPDATE) {
                Listener listener = getListener(element.getEntityClass());
                if(listenner != null) {
                    listener.notify(EventType.DELETE, true, prev.getId(), null, null);
                }
            }
        } finally {
            releaseIdLock(id, lock);
            rwLock.readLock().unlock();
        }
    }

    @Override
    public Map&lt;String, String&gt; getInfo() {
        HashNap&lt;String, String&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;size&quot;,Integer.toString(size()));
        result.put(&quot;state&quot;, consumer.getState().name());
        result.put(&quot;nextTime&quot;, DateUtils.formatl(concumer.getNextTime()));
        return result;
    }

    //自身的方法

    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    Conllection&lt;Element&gt; clearElements()  {
        rwLock.writeLock().lock();
        try {
            ArrayList&lt;Element&gt; result = new ArrayList&lt;&gt;(elments.values());
            elements.clear();
            return result;
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    // 获取队列中的元素数量
    public int size() {
        return elements.size();
    }

    // 停止状态
    private volatile boolean stop;

    // 停止更新队列并等待全部入库完成
    @Override
    public void shutdown() {
        stop = ture;
        consumer.stop();
        while(consumer.getState() != TimingConsumerState.STOPPED) {
            Thread.yield();
        }
    }

    public void flush() {
        consumer.flush();
    }

    public TimingConsumer getConsumer() {
        return consumer;
    }

    // 内同方法

    // 获取标识锁对象
    private Lock lockIdLock(String id) {
        // 获取当前的主键写锁
        ReentrantLock lock = locaks.get(id);
        if(lock == null) {
            lock = new ReentrantLock();
            ReentrantLock prevLock = locaks.putIfAbsent(id, lock);
            lock = prevLock != null ? prevLock : lock;
        }
        lock.lock();
        return lock;
    }

    // 释放锁标志锁
    private void releaseIdLock(String id, Lock lock) {
        lock.unlock();
        locks.remove(id);
    }

}
</code></pre>
<p>消费者</p>
<pre><code class="java">public class TimingConsumer implements Runnable  {
    private static Profile = new Profile();
    // 更新队列名
    private String name;
    // 入库间隔
    private int period;
    // 持久层的存储器
    private Accessor accessor;
    // 实体持久化缓存
    private TimingPersister owner;
    // 当前锁对象
    private final Object = new Object();

    // 状态
    private AtomicReference&lt;TimingConsumerState&gt; state = new AtomicReference&lt;&gt;(TimingConsumerStatee.WAITING);

    private volatile boolean stoped;
    // 下次执行的时间
    private Date nextTime;
    // 错误计数器
    private AtomicInteger error = new AtomicInteger();
    // 消费定时任务
    private static ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;

    static {
        ThreadGrop group = new ThreadGroup(&quot;定时任务&quot;);
        NamedThreadFactory threadFactory = new NamedThredFactory(group,&quot;定时储存任务&quot;);
        sheduledThreadPoolExcutor = new ScheduledThreadPoolExecutor(50,threadFactory);
    }

    public static void shutdownExecutor {
        if(scheduledThreadPoolExecutor != null) {
            scheduledThreadPoolExecutor.shutdown();
        }
    }

    public TimingConsuer() {
        this.name = name;
        this.period = Integer.valueOf(period);
        this.accessor = accessor;
        this.owner = owner;
        scheduledThreadPoolExecutor.scheduleFixedRate(this, 10L, this.period, TimeUnit.SECONDS);
    }

    @Override
    public void run() {
        if(stoped) {
            return;
        }
        try {
            synchronized(lock) {
                Collection&lt;Element&gt; elements = null;
                state.compareAndSet(TImgConsumerState.WAITING, TimingConsumerState.RUNNING);
                Date satart = new Date();
                if(logger.isDebugEnabled()) {
                    logger.debug(&quot;定时入库[{}]开始[{}]执行&quot;, name, DateUtils.formatl(start));
                }
                if(elements.isEmpty()) {
                    state.compareAndSet(TimingConsumerState.RUNNING, TingingConsumerState.WAITING);
                    return;
                }
                presist(elements);
                if(logger.isDebugEnabled()) {
                    logger.debug(&quot;定时入库[{}]入库[{}]条数据耗时[{}]&quot;, name, elements.size(),
                    System.currentTimeNillis() - start.getTime());
                }
                statat.compareAndSet(TimingConsumerState.RUNNING, TimingConsumerState.WAITING);
            }
        } catch (Throwable e) {
            logger.error(&quot;Timing执行异常&quot;, e);
            state.compareAndSet(TimingConsumerState.RUNNING, TimingCOnsumerState.WAITING);
        }
    }

    // 性能统计信息
    public static Profile collectTaskProfile(boolean rest) {
        Profile profile = TimingConsumer.profile;
        TimingConsumer.profile = new Profile();
        return profile;
    }

    // 记录失败数据
    private void recordFail(List&lt;AbstractEntity&gt; failList) {
        if(failList.isEmpty()) {
            return;
        }
        for(AbstractEntity abstractEntity : failList) {
            logger.error(&quot;{} entity {} update fail!&quot;, abstractEntity.getClass().getSimpleName(),
            abstractEntity.getId());
            logger.error(JsonUtils.object2String(abstractEntity));
        }
    }

    public TimingConsumerState getState() {
        return state.get();
    }

    public void stop() {
        if(logger.isDebugEnabled()) {
            logger.debug(&quot;定时入库[{}]收到停止通知&quot;,name);
        }

        synchronized(lock) {
            stop = true;
            Collection&lt;Element&gt; elements  = owner.clearElements();
            persist(elements);
            for(;;) {
                if() {
                   if() {
                       if(state.commpareAndSet(TimingConsumerState.WAITING, TimingConsumerState.STOPPED)) {
                           return;
                       }
                       try{
                           Thread.sleep(1000);
                       } catch(InterrupteException e) {
                           logger.error(&quot;停止队列被中断&quot;, e);
                       }
                   }
                }
            }
        }
    }

    // 立刻提交储存
    public void flush() {
        run();
    }

    public Date getNextTime() {
        return nextTime;
    }

    public int getError() {
        return error.get();
    }

    private void persist(Collection&lt;Element&gt; elements) {
        List&lt;AbstractEntity&gt; saveList = new ArrayList&lt;&gt;(500);
        List&lt;AbstractEntity&gt; updateList = new ArrayList&lt;&gt;(500);
        List&lt;AbstractEntity&gt; deleteList = new LinkedList&lt;&gt;();

        for(Element element : elements) {
            AbstractEntity entity = element.getEntity();
            try {
                profile.getOrCreateProInfo(elment.getEntityClass().getSimpleName()).recordSubmit();
                Class clz = element.getEntityClass();
                switch(element.getType()) {
                    case INSERT:
                        saveList.add(entity);
                        break;
                    case DELETE:
                        accesor.remove(clz, element.getId());
                        break;
                    casse UPDATE:
                        updateList.add(entity);
                        break;
                    default;
                }
                Listener listener = owener.getListener(clz);
                if(listener != null) {
                    listener.notify(element.getType(), true, element.getId(), entity, e);
                }
            } catch (RuntimeException e) {
                error.getAndIncrement();
                if(elment == null) {
                    logger.error(&quot;获取更新队列元素时线程被非法打断&quot;,e);
                } else {
                    logger.error(&quot;更新队列处理出现未知异常&quot;, e);
                }
            }
        }
    }


    List&lt;AbstractEntity&gt; fialList = accessor.batchSave(saveList);
    recordFail(failList);

    failList = accessor.batchUpdate(updateList);
    recordFail(failList);

    failList = accessor.batchDelete(deleteList);
    recordFail(failList);

}

</code></pre>
<p>队列消费者</p>
<pre><code class="java">public class QueueConsumer implements Runnable {
    // 更新队列名
    private final String name;
    // 更新队列
    private final BlockingQueue&lt;Elemnt&gt; queue;
    // 持久层的储存器
    private final Accessor accessor;
    // 所有者
    private final QueuePersister owner;
    // 当前消费者线程自身
    private final Thread me;
    // 错误计数器
    private final AtomicInteger error = new AtomicInteger();

    public QueueConsumer(String name, Acceossor accessor, BlockingQueue&lt;Element&gt; queue, QueuePersister owner) {
        this.name = name;
        this.accessor = accessor;
        this.queue = queue;
        this.owner = owner;
        this.me = new Thread(this, &quot;持久化[&quot;+ name+ &quot;队列]&quot;);
        me.setDaemon(true);
        me.start();
    }

    @Override
    public void run() {
        while(true) {
            Element element = null;
            Class clz = null;
            try {
                element = queue.take();
                clz = elment.getEntityClass();
                switch(element.getType()) {
                    case INSERT :
                        accessor.save(clz, element.getEntity());
                        break;
                    case DELETE :
                        accessor.remove(clz, elment.getId());
                        brea;
                    case UPDATE :
                        // 解除抑制
                        owner.removeUpdating(element.getIdentity());
                        accessor.update(clz, element.getEntity());
                        break;
                    deafault :
                    logger.error(&quot;未支持的更新队列元素类型[{}&quot;,element);
                    break;
                }
                Listener listener = owner.getListener(clz);
                if(listener != null) {
                    listener.notify(element.getType(), true, element.getId(), element.getEntity(), null;
                }
            } catch (RuntimeException e) {
                error.incrementAndGet();
                if(logger.isWareEnabled()) {
                    logger.warn(&quot;实体更新队列[{}]处理元素[{}]时出现异常: {}&quot;，new Obeject[] {name, element, e.getMessage()});
                }
                Listener listener = owner.getListener(clz);
                if(listener != null) {
                    listener.notify(element.getType(), false, element.getId(), element.getId(), element.getEntity(), e);
                }
            } catch (Throwable e) {
                error.incrementAndGet();
                if(element == null) {
                    logger.error(&quot;获取更新队列元素时线程被非法打断&quot;, e);
                } else {
                    logger.error(&quot;更新队列处理出现未知异常&quot;, e);
                }
            }

        }
    }

    public int getError() {
        return error.get();
    }
}

</code></pre>
<h2 id="服务逻辑"><a href="#服务逻辑" class="headerlink" title="服务逻辑"></a>服务逻辑</h2><p>实体增强服务接口</p>
<pre><code class="java">public interface EnhanceEnhanceService&lt;PK extends Comparable&lt;PK&gt; &amp; Serializable, T extends AbstractEntity&lt;PK&gt;&gt; extends 
EnhanceService&lt;PK,T&gt; {

    // 检查指定的唯一属性域值是否存在
    boolean hasUniqueValue(String name, Object value);

    // 替换指定实体标识对应的唯一属性缓存值
    void replaceUniqueValue(PK id, String name, Object value);

}

</code></pre>
<pre><code class="java">@Transactional(rollbackFor = Exception.class)
public class EntityCacheServiceImpl&lt;PK ezxtends Comparable&lt;PK&gt; &amp; Serialzable, T extends AbstractEntity&lt;PK&gt;&gt; implements 
EntityCacheService&lt;PK, T&gt;, CacheFinder&lt;PK, T&gt;, EntityEnhanceService&lt;PK, T&gt; {

    // 初始化标识
    private boolean initialize;
    // 实体类型
    private Class&lt;T&gt; entityClz;
    // 缓存实体配置信息
    private CachedEntityConfig config;
    // 存储器
    private Accessor accessor;
    // 查询器
    private Querier querier;
    // 持久化缓存器
    private Persister persister;
    // 实体缓存
    private Cache&lt;PK,T&gt; cache;
    // 主键缓存
    private ConcurrentHashSet&lt;PK&gt; biyPrimarKeys;
    // 初始化方法
    public synchronized void initialize(CacheEntityConfig config, Persister persister, Accessor accesoor, Querier querier) {
        if(initialize) {
            throw new StateException(&quot;重复初始化异常&quot;);
        }
        // 初始化属性域
        initFields(config, persister, accessor, querier);
        // 缓存初始化处理
        initCaches(config, querier);
        // 缓存主键
        cacheBitPremaryKey(querier);
        this.initialize = ture;
    }

    // 实体操作读写锁
    private ConcurrentHashMap&lt;PK, ReentrantLock&gt; locks = new ConcurrentHashMap&lt;&gt;();
    // 正在被移出的实体的主键集合
    private ConcurrentHashSet&lt;PK&gt; removing = new ConcurrentHashSet&lt;&gt;();
    // 唯一键缓存(key： 唯一键名， value:{key:唯一键值, value:PK})
    private HashMap&lt;String, HashBiMap&gt; uniques;

    @Override
    public T getMaybeNull(PK id) {
        return cache.getIfPresent(id);
    }
    @Overide
    public T load(PK id) {
        unInitializeThrowException();
        if(isMaybeNotExist(id)) {
            // 不存在的主键
            return null;
        }
        // 想判断主键是否有效
        if(!removing.contains(id)) {
            // 尝试从缓存中获取
            T current = (T) cache.getIfPresent(id);
            if(current != null) {
                return current;
            }
        }
        // 抑制并发错误
        T currnent = null;
        // 获取主键锁，抑制并发操作
        Lock lock = lockPkLock(id);
        try {
            // 先判断主键是否有效
            if(removing.contains(id)) {
                return null;
            }
            // 尝试从缓存中获取
            current = cache.getIfPresent(id);
            if(current != null) {
                // 尝试反序列化
                current.unSeralize();
                if(config.hasUniqueField())
                    // 添加唯一属性缓存信息
                    Map&lt;String, Object&gt; uniqueValues = config.getUniqueValues(current);
                    for(Entry&lt;String, Obeject&gt; entry : uniqueValues.entrySet()) { 
                        addUniqueValue(entry.getKey(), entry.getValue(), id);
                    }
            }
            cache.put(id, current);
        } finally {
            // 释放主键锁
            releasePkLock(id, lock);
        }
        return current;
    }

    // 实体增强相关的方法

    @Override
    public CacheFinder&lt;PK, T&gt; getFinder() {
        unInitializeThrowException();
        return this;
    }

    //....

    @Override
    public Set&lt;T&gt; add() {
        unInitializeThrowException();
        HashSet&lt;T&gt; result = new HashSet&lt;&gt;(cache.asMap().values());
        return result;
    }

    // 管理相关的方法实现


    @Override
    public CacheEntryConfig getEntityConfig() {
        unInitializeThrowException();
        return config;
    }

    @Override
    public Persister getPersister() {
        return persister;
    }

    @Override
    public void shutdown() {
        cache.asMap().values().foreach(t -&gt; {
            if(t.getSumitMark().compareAndSet(true, false)) {
                // 序列化
                try {

                } catch (Exception e) {
                    logger.error(&quot;entity serialize error!&quot;, e);
                    return;
                }
                // 储存
                writeBack();
            }
        });
    }

    // 内部方法

    // 添加指定唯一属性值与主键的对应关系（属性名的写锁保护）
    private void initFields(final CachedEntityConfig, final Persister persiter, Accessor accessor, Querier querier) {
        Cached cached = config.getCached();
        // 初始化属性域
        this.config = config;
        this.accessor = accessor;
        this.querier = querier;
        this.enrityClz = querier;
        this.entityClz = (Class&lt;T&gt;) config.getClz();
        this.persister = persister;
        this.persister.addListener(entityClz, new AbstractListener {
            @Override
            protected void onRemoveSuccess(Serializable id) {
                removing.remove(id);
            }
            @Override
            protected void onRemoveErroe() {
                removing.remove(id);
            }
            @Override
            protected void onSaveError() {
                if(ex instanceof ConcurrentModificationException) {
                    persister.put(Element.saveOf(entity));
                }
            }
            @Override
            protected void onUpdateError(AbstractEntity entity, RuntimeException ex) {
                if(ex instanceof ConcurrentModificationException) {

                }
            }
        });

        // 初始化唯一键信息
        if(config.hasUniqueFiled()) {
            this.uniques = config.buildUniqueCache();
        }
        // 初始化实体缓存空间
        switch(cached.type()) {
            case LRU:
                if(config.hasUniqueField()) {
                    this.cache = CacheBuilder.newBuilder().removalListener((RemovalListener&lt;PK, T&gt;) notification -&gt; {
                        for(Entry&lt;String, HashBiMap&gt; entry : uniques.entrySet()) {
                            WriteLock lock = config.getUniqueWriteLock(entry.getKey());
                            lock.lock();
                            try {
                                entry.getValue().inverse().remove(notification.getValue().getId());
                            } finally {
                                lock.unlock();
                            }
                        }
                    }).weakValues().build();
                } else {
                    this.cache = CacheBuilder.newBuidler().weakValues().build();
                }
                break;
            case MANUAL:
                this.cache = CacheBuilder.newBuilder().maximumSize(Integer.MAX_VALUE).build();
                break;
            default:
                throw new ConfigurationException(&quot;未支持的缓存管理类型[&quot;+ cached.type()+ &quot;]&quot;);
        }
    }

    // 缓存主键
    private void cacheBitPrimaryKey(Querier querier) {
        int count = querier.count(entityClz);
        if(count &gt; 100) {
            // 数;据量打，不缓存主键了
            return;
        }
        // 初始化主键索引，避免新开服大量无效的select操作
        List&lt;T&gt; all = querier.all(entityClz);
        bitPrimaryKeys = new ConcirrentHashSet&lt;&gt;();
        for(T t : all) {
            bitPrimaryKeys.add(t.getId());
        }
    }

    // 检测主键缓存存在的情况，是否存在主键
    private boolean isMaybeNotExist(PK pk) {git
        if(bitPrimarykeys == null) {
            // 没有做缓存操作
            return false;
        }
        return !bitPrimaryKeys.contains(pk);
    }

    // 尝试缓存主键，如果没有做过缓存，不用缓存例如，如果已经做过缓存，则缓存新创建的主键
    private void tryCacheBitPrimaryKey(Pk pk) {
        if(bitprimaryKeys == null) {
            // 没有缓存操作
            return;
        }
        bitPrimaryKeys.add(pk);
    }

    // 初始化缓存数据
    private void initCache(CacheEntityConfig config, Querier querier) {
        InitialConfig initial = config.getInitialConfig();
        if(initial == null) {
            return;
        }        
        // 获取要初始化的实体列表
        List&lt;T&gt; entities = null;
        switch(initial.type()) {
            case ALL:
                entities = querier.all(entityClz);
                break;
            case QUERY:
                entities = querier.list(entityClz, initial.query());
                break;
            default:
                throw new ConfigurationException(&quot;无法按配置[&quot;+ initial + &quot;]初始化实体[&quot;+this.entityClz.getName()+&quot;]的缓存&quot;);
        }
        // 初始化缓存数据
        for(T entity : entities) {
            // 尝试初始化
            entity,unSerialize();
            PK id = entity.getId();
            cache.put(id, entity);
            if(config.hasUniqueField()) {
                Map&lt;String, Obeject&gt; uniqueValues = config.getUniqueValues(entity);
                // 更新唯一键索引
                for(Entry&lt;String, Object&gt; entry : uniqueValues.entrySet()) { 
                    HashBiMap unique = uniques.get(entry.getKey();
                    unique.put(entry.getValue(), id);
                }
            }
        }
    }

    @Override
    public long getAllSzie {
        return this.cache.size()
    }
    @Override
    public T create(PK id, EntityBuider&lt;PK, T&gt; builder) {
        unInitializeThrowException();
        // 先判断主键是否有效
        if(!removing.contains(id)) {
            // 尝试从缓存中获取
            T current = (T) cache.getIfPresent(id);
            if(current != null) {
                return current;
            }
        }
        // 抑制并发操作
        T current = null;
        // 获取主键锁，抑制并发操作
        Lock lock = lockPkLock(id);
        try {
            // 尝试从缓存中获取
            current = (T) cache.getIfPresent(id);
            if(currnt != null) {
                return current;
            }
            boolean flag = removing.contains(id);
            // 创建实例
            current = builder.newInstance(id);
            if(current == null) {
                throe new InvaildEntityException(&quot;创建返回null&quot;);
            }
            if(current.getId() == null) {
                 throe new InvaildEntityException(&quot;创建的主键为null&quot;);
            }
            if(config.hasUniqueFiled()) {
                // 检查唯一属性性值是否合法
                Map&lt;String,, Object&gt; uniqueValues = config.getUniqueValues(current);
                // 迭代每一个唯一属性域
                for(Entry&lt;String, Object&gt; entry : uniqueValues.entrySet()) {
                    // 唯一属性域名
                    String uniqueName = entry。getKey();
                    // 唯一属性域值
                    Obejct uniqueValue = entry.getValue();
                    WriteLock uniqueLock = config.getUniqueWriteLock(uniqueName);
                    uniqueLcok.lock();
                    try {
                        // 检查缓存数据
                        HashBiMap unique = uniques.get(uniqueName);
                        // 更新缓存数据
                        PK prev = (PK) unique.put(uniqueValue, id);
                        if(prev != null) {
                            logger.error(&quot;实体主键异常&quot;);
                        }
                    } finally {
                        uniqueLock,unlock();
                    }
                }
            }
            if(flag) {
                removing.remove(id);
            }

            // 创建ok了序列化一次
            current.trySerialize();
            //尝试缓存主键
            tryCacheBitPrimaryKey(id);
            // 异步持久化
            persister.put(Element.saveOf(current));
            cache.put(id , current);
            return current;
        } finally {
            // 释放主键锁
            releasePkLock(id, lock);
        }

    }


}

</code></pre>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>对象锁对象</p>
<pre><code class="java">/**排序顺序说明：

1. 非实体在前，实体{@link AbstractEntity}在后
2. 不同类型的锁对象，按类型{@link Class}的hashCode值的大小进行排序
3. 不同类型的锁对象，当不幸遇到hashCode值相同的情况，用完整类名做字符串排序
4. 类型相同时，更具&lt;/code&gt;排序依据&lt;/code&gt;进行排序
5. &lt;code&gt;排序依据&lt;/code&gt;对于非实体而言，为&lt;code&gt;System.identityHashCode(instance)&lt;/code&gt;
6. &lt;code&gt;排序依据&lt;/code&gt;对于实体而言，为{@link AbsteactEntity#getIdentity}
*
**/
public class ObjectLock extends ReentrantLock implements Comparable&lt;ObjectLock&gt; {

    private static final Class&lt;AbstractEntity&gt; IENTIT_CLASS = AbstractEntity.class;

    // 锁定对象的类型
    private final Class clz;
    // 锁的排序依据
    private final Comparable value;
    // 该对象锁所锁定的是否实体

    // 构造指定对象的对象锁
    public ObejctLock(Object object) {
        this(object, false);
    }
    // 构造指定对象的对象锁
    public ObejectLock(Obejct object, boolean fair) {
        super(fair);
        clz = obeject.getClass();
        if(object instanceof AbstractEntity) {
            value = (Comparable) ((AbstractEntity) object).getId();
        } else {
            value = new Integer(System.identityHashCode(object));
        }
        if(IENTITY_CLASS.isAssignableFrom(clz)) {
            entity = true;
        } else {
            entity = false;
        }
    }

    /** 检查当前锁是否无法和另一锁分出先后次序
        @param other 与当前锁比较的另一锁
    */
    public boolean isTie(Obeject other) {
        if(this.clz != other.clz) {
            return false;
        }
        if(this.value.compareTo(other.value) == 0) {
            return true;
        }
        return false;
    }

    // 锁定对象的类型
    public Class getClz() {
        return clz;
    }
    // 获取排序依据
    public Comparable getValue() {
        return value;
    }

    // 检查对象锁所锁定的是否实体
    public boolean isEntity() {
        return entity;
    }

    // 检查对象锁所在的是否实体
    public boolean isEntity() {
        return entity;
    }

    // 检查该对象锁所锁定的是否实体
    public boolean isEntity() {
        return entity;
    }

    @Override
    public int compareTo(ObejectLock o) {
        // 实体和非实体间的排序
        if(this.isEntity() &amp;&amp; !o.isEntity()) {
            return 1;
        } else if(!this.isEntity() &amp;&amp;o.isEntity()) {
            return -1;
        }
        if(this.clz != o.clz) {
            // 类型不同的排序
            if(this.clz.hashCode() &lt; o.clz.hashCode()) {
                return -1;
            } else if (this.hashCode() &gt; o.clz.hashCode()) {
                return 1;
            }
            return this.clz.getName().compareTo(o.clz.getName());
        } else {
            // 类型相同的处理
            return this.value.compareTo(o.value);
        }
    }

}

</code></pre>
<h2 id="对象映射"><a href="#对象映射" class="headerlink" title="对象映射"></a>对象映射</h2><p>查询接口</p>
<pre><code class="java">/**
*  物理存储层的数据查询器接口
*   用于给不同的ORM底层实现
*/
public interface Querier {
    // 表数据条数
    &lt;T&gt; int count(Class&lt;T clz);
    // 获取全部实体
    &lt;T&gt; List&lt;T&gt; all(Class&lt;T&gt; clz);
    // 获取指定命名查询的查询结果（返回实体列表）
    &lt;T&gt; List&lt;T&gt; list(Class&lt;T&gt; clz, String queryname, Object... params);
    // 获取指定命名的查询结果（返回投影内容列表）
    &lt;E&gt; List&lt;E&gt; list(Class entityClz, Class&lt;E&gt; retClz, String queryname, Object... params);
    // 获取指定命名查询的查询结果（返回单一的实体对象实例）
    &lt;T&gt; T unique(Class&lt;T&gt; clz, String quertname, Obeject... params);
    // 获取指定命名查询的查询结果(返回单一的投影内容)
    &lt;E&gt; E unique(Class entityClz, Class&lt;E&gt; retClz, String queryname, Obejct... params);
    // 分页查询（返回实体列表）
    &lt;T&gt; List&lt;T&gt; paging(Class&lt;T&gt; clz, String queryname, Paging paging, Object... params);
    // 分页查询（返回投影内容列表）
    &lt;T&gt; List&lt;E&gt; paging(Class entityClz, Class&lt;E&gt; retClz, String queryname, Paging paging, Object... params);
    // 删除数据，慎用
    &lt;T&gt; int delete&lt;Class&lt;T&gt; clz, final String queryname, final Object... params&gt;);

}

</code></pre>
<p>数据访问器接口</p>
<pre><code class="java">/**
物理存储层数据访问器接口
用于给不同的ORM底层实现
*/

public interface Accessor {
    // 从存储层加载指定的实体对象实例
    &lt;PK extends Serializable, T extends AbstractEntity&gt; T load(Class&lt;T&gt; clz, PK id);

    // 持久化指定的实体实例，并返回实体的主键值对象
    &lt;Pk extends Serializable, T extends AbstractEntity&gt; void save(Class&lt;T&gt; clz, T entity);

    // 从存储层移除指定实体
    &lt;PK extends Serializable, T extends AbstractEntity&gt; void remove(Class&lt;T&gt; clz, PK id);
    // 更新储存层的实体数据（不允许更新实体的主键值）
    &lt;PK extends Serializable, T extends AbstractEntity&gt; void update(Class&lt;T&gt; clz, T entity);
    // 批量储存
    &lt;PK extends Serializable, T extends AbstractEntity&gt; List&lt;T&gt; batchSave(final List&lt;T&gt; entitys);
    // 批量更新
    &lt;PK extends Serializable, T extends AbstractEntity&gt;  List&lt;T&gt;  batchUpdate(final List&lt;T&gt; entitys);
    // 批量删除 
    // @return 失败数据集合
    &lt;Pk extends Serializable, T extends AbstractEntity&gt; List&lt;T&gt; batchDelete(final List&lt;T&gt; entitys);
}

</code></pre>
<p>Accessor的Hibernate实现</p>
<pre><code class="java">public class HibernateBAccessor extends HibernateDaoSupport implements Accessor {
    private IHibernateBeforeLoad hibeenateBeforeLoad;

    @Override
    public &lt;PK extends Serializable, T extends AbstractEntity&gt; T load(Class&lt;T clz, PK id) {
        if(hibeenateBeforeLoad != null) {
            hibeenateBeforeLoad.beforeLoad(clz, id);
        }
        return getHibernateTemplate().execute(session -&gt; {
            session.beginTransation();
            T t = session.get(clz, id);
            session.getTransaction().commit();
            return t;
        });
    }

    @Override
    public &lt;PK extends Serialization, T extends AbstractEntity&gt;  void save(Class&lt;T&gt; clz, T entity) {
        batchExc(Collections.singletonList(entity), Session::save);
    }
    @Override
    public &lt;Pk extends Serializable, T extends AbstractEntity&gt; void remove(Class&lt;T&gt; clz, T entity){
        T entity = load(clz, id);
        if(entity == null) {
            return;
        }
        batchExc(Collections.singletonList(entity), Session::delete);
    }
        @Override
    public &lt;PK extends Serialization, T extends AbstractEntity&gt;  void save(Class&lt;T&gt; clz, T entity) {
        batchExc(Collections.singletonList(entity), Session::update);
    }
    @Override
    public &lt;PK extends Serializable, T extends AbstractEntity&gt; List&lt;T&gt; batchSave(final List&lt;T&gt; entitys) {
        batchExc(ntitys, Session::save);
    }
    @Override
    public &lt;PK extends Serializable, T extends AbstractEntity&gt; List&lt;T&gt; batchUpdate(final List&lt;T&gt; entitys) {
        batchExc(entitys, Session::update);
    }
    @Override
    public &lt;PK extends Serializable, T extends AbstractEntity&gt; List&lt;T&gt; batchDelete(final List&lt;T&gt; entitys) {
        batchExc(entitys, Session::delete);
    }

    privte &lt;PK extends Serializable, T extends AbstractEntity&gt;  List&lt;T&gt; batchExc(List&lt;T&gt; entitys, BitConsumer&lt;Session, T&gt; consumer) {
        if(entitys.isEmpty()) {
            return Collections.emptyList();
        }
        List&lt;T&gt; failList = new ArrayList&lt;&gt;(0);
        int size = entitys.size();
        int szie = entitys.size();
        int index =0;
        int oneBatch = 100;
        while(index &lt; size) {
            List&lt;t&gt; oneList = entitys.subList(index, Math.min(size, index+oneBatch));
            try {
                // 先尝试批量
                getHibernateTemplate().execute(session -&gt; {
                    session.beginTransaction();
                    for(T t : oneList) {
                        consumer.accept(session, t);
                    }
                    session.getTransaction().commit();
                    return oneList.size();
                    });
                } catch(Exception e) {
                    loggrt.error(&quot;批量处理出现未知异常&quot;, e);
                    // 批量执行出错，单个提交
                    for(T t : oneList) {
                        getHibernateTemplate().execute(session -&gt; {
                            try {
                                session.beginTransaction();
                                consumer.accept(session, t);
                                session.beginTransation().commit();
                            } catch(Exception e1) {
                                // 记录失败单位
                                faolList.add(t);
                                logger.error(String.format(&quot;单个处理出现未知异常%s, id: %s&quot;)，t, t.getId()), e1);
                            }
                            return 1;
                        });
                    }
                } finally {
                    index += oneList.size();
                }
            return failList;
        }
    }

    public IHibrenateBeforeLoad getHibernateBeforeLoad() {
        return hibernateBeforeLoad;
    }

    public void setHiberbateBeforeLoad(IHibrenateBeforeLoad hibernateBeforeLoad) {
        this.hibernateBeforeLoad = hibernateBeforeLoad;
    }
}
</code></pre>
<p>Querier的Hibernate实现</p>
<pre><code class="java">public class HiberbateQuerier extends HibernateDaoSupport implements Querier {
    @Override
    public &lt;T&gt; int count(Class&lt;T&gt; clz) {
        return getHibernateTemplate().execute(session -&gt; {
            session.beginTransaction();
            int size = ((Long)) session.createCriteria(clz).setProjection(Projections.rowCount()).list().get(0).intValue();
            session.flush();
            session.clear();
            session.getTransaction().commit();
            return size;
        });
    }


    @Override
    public &lt;T&gt; List&lt;T&gt; all(Class&lt;T&gt; clz)  {
        return getHibernateTemplate().execute(session -&gt; {
            session.beginTransaction();
            List&lt;T&gt; list = session.createCriteria(clz).list();
            session.flush();
            session.clear();
            session.getTransation().commit();
            return size;
        });
    }

    @Override
    public &lt;T&gt; List&lt;T&gt; list(Class&lt;T&gt; clz, String queryname, Object... params) {
        return getHibernateTemplate().execute(session -&gt; {
            session.beginTransaction();
            Query query = session.getNameQuery(queryname);
            for(int i=0; i&lt;parmas.length; i++) {
                query.setParameter(String.valueOf(id), params[i]);
            }
            List&lt;T&gt; list = query.list();
            session.flush();
            session.clear();
            session.getTransaction().commit();
            return list;
        });
    }

    @Override
    public &lt;E&gt; List&lt;E&gt; list(Class entityClz, Class&lt;E&gt; retClz, String queryname, Obeject... params) { 
        return list(retClz, queryname, params);
    }

    @

    @Override
    public &lt;T&gt; T unique(Class&lt;T&gt; clz, final String queryname, final Object... params) {

    }

    @Override
    public &lt;E&gt; List&lt;E paging(Class&lt;T&gt; clz, final String queryname, final Paging paging, final Object... params) {
       return getHibernateTemplate().execute(session -&gt; {
        session.beginTransation();
        Query query = session.getNameQuery(queryname);
        for(int i=0; i&lt;params.length; i++&gt;) {
            query.setParameter(String.valueOf(i), params[i]);
        }
        query.setFirstResult(paging.getFirst());
        query.setMaxResults(paging.getSize());
        List&lt;T&gt; list = query.list();
        session.flush();
        session.clear();
        session.getTransaction().commit();
        return list;
        });
    }

    @Overide
    public &lt;E&gt; List&lt;E&gt; paging(Class entityClz, Class&lt;E&gt; retClz, final String queryname, final Paging paging, final Object... params) {
        return paging(retClz, queryname, paging, params);
    }

    @Override
    public &lt;T&gt; int delete(Class&lt;T&gt; clz, final String querybame, final Object... params) {
        return getHiberbateTemplate().execute(session -&gt; {
            session.beginTransaction();
            Query query = session.getNameQuery(queryname);
            for(int i=0;i&lt; params.lenght; i++&gt;) {
                query.setParameter(String.valueOf(i), params[i]);
            }
            int result = query.executeUpdate();
            session.flush();
            session.clear();
            session.getTransation().commit();
            return result;
        });
    }
 }
</code></pre>
<h2 id="缓存服务管理器"><a href="#缓存服务管理器" class="headerlink" title="缓存服务管理器"></a>缓存服务管理器</h2><pre><code class="java">public class  ServiceManager implements ServiceManagerMBean {

    // 存储器
    private final Accessor accessor;
    // 查询器
    private final Querier querier;
    // 持久化缓存配置信息
    private final Map&lt;String, PersisterConfig&gt; persisterConfigs;
    // 实体对应的配置信息
    private final Map&lt;Class&lt;? extends AbstractEntity&gt;, CacheEntityConfig&gt; entityConfigs = new HashMap&lt;&gt;();
    // 队列配置名对应的队列实例
    private final Map&lt;String, Persister&gt; peristers = new HashMap&lt;&gt;();
    // 实体对应的缓存服务对象
    private final Map&lt;Class&lt;? extends AbstractEntity&gt;, EntityCacheSerice&gt; entityService = new HashMap&lt;&gt;();
    // 实体对应的缓存服务对象
    private final Map&lt;Class&lt;? extends AbstractEntity&gt;, RegionCacheService&gt; regionSerices = new HashMap&lt;&gt;();

    // 初始化方法
    public ServiceManger(Set&lt;Class&lt;AbstractEntity&gt;&gt; entityClasses, Accessor accessor, Querier querier, Map&lt;&lt;String, Integer&gt; constants,
    Map&lt;String, PersisterConfig&gt; persisterConfigs) {
        Assert.notNull(accessor, &quot;存储器不能为空&quot;);
        Assert.notNull(querier, &quot;查询器不能未空&quot;);
        Assert.notNull(entityClasses, &quot;实体类配置集合不能为空&quot;);
        this.accessor = accessor;
        this.querier = querier;
        this.persisterConfis = persisterConfigs;
        for(Class&lt;? extends AbstractEntity&gt; clz : entityClasses) {
            if(!CacheEntityConfig.isVaild(clz, constants)) {
                throw new ConfigurationException(&quot;无效的缓存实体[&quot;+ clz.getName() + &quot;]配置&quot;);
            }
            // 获取实体缓存配置信息
            CachedEntityConfig config = CachedEntityConfig.valueOf(clz, constants);
            entityConfigs.put(clz, config);
        }
        // 注册MBean
        try {
            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
            ObjectName name = new ObejctName(&quot;com.my9yu.common:type=CacheServiceMBean&quot;);
            mbs.registerMbeab(this,name);
        } catch(Exception e) {
            logger.error(&quot;注册[common-ramcache]的JMX管理接口失败&quot;, e);
        }
    }

    // 获取指定实体的缓存服务对象
    public void EntityCacheService(Class&lt;? extends AbstractEntity&gt; clz) {
        CachedEntityConfig config = entityonfigs.get(clz);
        if(config == null) {
            throw new StateException(&quot;类[&quot;+ clz.getName() + &quot;]不是有效的缓存实体&quot;);
        }
        if(!config.cacheUnitIs(CacheUnit.ENTITY)) {
            throw new StatException(&quot;实体[&quot;+ clz.getName() + &quot;]的缓存单位不是[&quot;+ CacheUnit.ENTITY +&quot;]&quot;);
        }
        EntityCacheService result = entityService.get(clz);
        if(result != null) {
            return result;
        }
        return createEntityService(clz);
    }

    // 停止全部实体更新队列
    public void shutdown() {
        if(logger.isDebugEnabled()) {
            logger.debug(&quot;开始停止实体更新队列&quot;);
        }
        for(EntityCacheService entityCacheService : entityService.value()) {
            entityCacheService.shutdown();
        }
        for(Persister queue : persisters.values()) {
            queue.shoutdown();
        }
        // 关闭线程
        TimingConsumer.shutdownExecutor();
    }

    // JMX的管理方法实现....

    // 创建缓存服务对象
    private synchronized EntityCacheService createEntityService(Class&lt;? extends AbstractEntity clz&gt;) {
        if(entityServices.containsKey(clz)) {
            return entityServices.get(clz);
        }
        CacheEntityConfg config = entityConfigs.get(clz);
        String name = clz.getSimpleName();
        Persister queue = getPersister(name);
        // 创建实体缓存服务对象
        EntityCacheService config = entityConfigs.get(clz);
        String name  = clz.getSimpleName();
        Persister queue = getPersister(name);

        // 创建实体缓存服务对象
        EntityCacheServiceImpl result = new EntityCacheServiceImpl();
        result.initialize(config, queue, accessor, querier);
        entityService.put(config.getClz(), result);
        return result;
    }

    // 获取持久化处理器实例
    private Persister getPersister(String name) {
        Persister result = persisters.get(name);
        if(result != null) {
            return result;
        }
        result = new TimingPersister();
        result.initialize(name, accessor, 10);
        persister.put(name, result);
        return result;
    }
}
</code></pre>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><pre><code class="java">public class RamCacheParser extends AbstractBeanDefinitionParser {

    // 默认资源匹配符
    protected static final String DEFAULT_RESOURCE_PATTERN = &quot;**/*.class&quot;;
    // 资源搜索分析器，由它来负责检索EAO接口
    private REsourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();
    // 类的元数据读取器，由它负责读取类上的注释信息
    private MetadataReaderFactory metadateReaderFactory = new CacheingMetadataReaderFactory(this.resourcePatter);

    @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})  
    @Override
    protected AbstractBeanDefubution parseInternal(Elment element, ParseContext parseContext) {
        // 注册注入处理器
        registerInjectProcessor(parseContext);

        // 注册锁拦截切面
        if(Boolean.valueOf(element.getAttribute(AttributeNames.LOCK_ASPECT))) {
            registerLockAspect(parseContext);
        }
        // 创建工厂类定义
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceFactory.class);

        // 设置存储器
        builder.addPropertyReference(ElementNames.ACCESSOR, getAccessorBeanName(element));
        // 设置查询器
        builder.addPropertyReference(ElementName.QUERIER, getQuerierBeanName(element));

        // 设置实体集合
        Set&lt;Class&lt;? extends AbstractEntity&gt;&gt; classess = new HashSet&lt;&gt;();
        NodeList child = DomUtils.getChildElementByTagName(element, ElementNames.ENTITY).getChildNodes();
        for(int i=0; i&lt;child.getLength(); i++) {
            Node node = child.item(i);
            if(node.getNodeType() != Node.ELEMENT_NODE) {
                continue;
            }
            String name = node.getLocalName();
            if(name.equals(ElemntNames.PACKAGE)) {
                // 自动包扫描处理
                String packageName = ((Element)node).getAttribute(AttributeNames.NAME);
                String [] names = getResources(packageName);
                for(String resource : names) {
                    Class&lt;? extends AbstractEntity&gt; clz = null;
                    try {
                        clz = (Class&lt;? extends AbstractEntity&gt;) Class.forName(className);
                    } catch (ClassNotFoundException e){
                        FormattingTupe message = MessagFormatter.format(&quot;无法获取的资源类[{]}]&quot;, className);
                        logger.error(message.getMessage());
                        throw new ConfigurationException(message.getMessage(), e);
                    }
                    classes.add(clz);
                }
            }
        }
        builder.addPropertyValue(ServiceManagerFactory.ENTITY_CLASSES_NAME, classes);
        return builder.getBeanDefinition();
    }


    private void parseConstants2Bean(BeanDefinitionBuilder builder, Elment element, ParseContext parseContext) {
        String ref = element.getAttribute(AttributeNames.REF);
        // 引用设置
        if(StringUtils.isNotBlank(ref)) {
            builder.addPropertyReference(ElementNames.CONSTANTS, ref);
            return;
        }
        // 指定设置
        ManageMap&lt;String, Integer&gt; constants = new ManagedMap&lt;&gt;();
        for(Element e : DomUtils.getChildElementByTagName(element, ElementNames.CONSTANT)) {
            String name = e.getAttribute(AttributeNames.NAME);
            Integer value = Integer.paresInt(e.getAttributeNames.NAME);
            Integer value = Integer.parseInt(e.getAttribute(AttributeNames.SIZE));
            constans.put(name, vaalue);
        }  
        builder.addPropertyValue(ElementNames.CONSTANS， constants);
    }

    // 注册锁切面
    private void registerLockAspect(ParseContext parseContext) {
        BeanDefinitionRegistry registry = parserContext.getRegistry();
        String name= StringUtils.uncapitalize(LockAspect.class.getSimpleName);
        BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(LockAspect.class);
        registry.registerBeanDeFinition(name, factory );
    }

    // 注册注入处理器，为后面通过`@Inject`注解注入CacheService做准备
    private void registerInjectProcessor() {
        BeanDefinitionRegistry register = parseContext.getRegistry();
        String name = StringUtils.uncapitalize(InjectProcessor.class.getSumpleName());
        registry.registerBeanDefinition(name, factory.getBeanDefinition());
    }

    // 获取查询器配置德Bean引用
    private String getQueierBeanName(Elmement element) {
        // ....
    }

    // 获取存储器配置的Bean引用
    private String getAccessorBeanName(Element element) {
        elment = ParserHelper.getUniqueChildElementByTagName(elment, ElementNames.ACCESSOR);
        // 引用处理
        if(elment.hasAttribute(AttributeNames.REF)) {
            return element.getAttribute(AttributeNames.REF);
        }
        throw new ConfigurationException(&quot;储存器配置声明缺失&quot;);
    }

    // 获取指定报下的静态资源对象
    private String[] getResource(String packageName) {
        try {
            // 搜索资源
            String packageSearchPath = ResourcePaatternResolver.CLASSPATH_ALL_URL_PREFIX
                + resolveBasePackage(packageName) + &quot;/&quot; + DEFULT_RESOURCE_PATTERN;
            Resource[] resources = this.resouorcePatternResolver.getResources(packageSearchPath);
            // 提取资源
            Set&lt;String&gt; result = new HashSet&lt;&gt;();
            String name = Cached.class.getName();
            for(Resource resource : resources) {
                if(!resource.isReadable()) {
                    continue;
                }
                // 判断是否静态资源
                MetadataReader metaReader = this.metadataReaderFactory.getMetadataReader(resource);
                AnnotationMetadata ammoMeta = metaReader.getAnnotationMetadata();
                if(!annoMeta.hasAnnotation(name)) {
                    continue;
                }
                ClassMetadata clzMeta = metaReader.getClassMetadata();
                result.add(clzMeta.getClassName());
            }
            return result.toArray(new String[0]);
        } catch(IOExeption e) {
            throw new ConfigurationException(message, e);
        }
    }

    protected String resolveBasePackage(String basePackage) {
        return ClassUtils.converClassNameToResourcePath(SystemPropertyUtils.resolvePlaceholder(basePackage));
    }
}
</code></pre>
<p>缓存服务注入处理器，负责完成{@link Inject}声明的资源注入工作</p>
<pre><code class="java">public class InjectProcessor extends InstantionAwareBeanPostProcessorAdapter implements Ordered () {
    @Autowired
    private ServiceManager manager;

    @Override
    public boolean postProcessAfterInstantiation(final Obeject bean, final String beanName) throws BeanException{ 
        ReflectionUtils.doWithFileds(bean.getClass(), new FIeldCallback() {
            Inject anno = filed.getAnnotation(Inject.class);
            if(anno == null) {
                return;
            }
            if(field.getType().equals(EntityCacheService.class)) {
                // 注入实体单位缓存服务
                injectEntityCacheService(bean, beanName.field);
            } else if(field.getType().equals(RegionCacheSercie)) {
                // 注入区域单位缓存服务
                injectRegionCacheService(bean, beanName, field);
            } else {
                FormattingTuple message = MessageFormatter.format(&quot;Bean[]的注入属性[]类型声明错误&quot;, beanName, field.getName());
                logger.error(message.getMessage());
                throw new ConfigurationException(message.getMessage());
            }
        });
        return super.postProcessAfterInstantiation(bean, beanName);
    }

    // 注入实体单位缓存服务
    private void injectEntityCacheService(Obejct bean, String beanName, Field field) {
        Class&lt;? extends AbstractEntity&gt; clz = null;
        EntityCacheService service = null;
        try {
            Type type = field.getGenericType();
            Type[] types = ((ParameterizedType) type).getActualTypeArguments();
            clz = (Class&lt;? extends AbstractEntity&gt;) types[1];
            service = manager.getEntityService(clz);
        } catch(Exception e) {
            FormattingTuple message = MessageFormatter.format(&quot;Bean[{}]的注入属性[{}]声明错误&quot;，beanName, field.getName());
            throw new CongigurationException(message.getMessage(), e);
        }
        if(service == null) {
            FormatitingTupe message = MessageFormatter.format(&quot;实体[{}]缓存对象不存在&quot;, clz.getName());
            throw new ConfigurationException(message.getMessage());
        }
        inject(beanm field, service);
    }

    // 注入属性值
    private void inject(Obejct bean, Field field, Obejct value) {
        ReflectionUtils.makeAccessible(field);
        try {
            filed.set(bean, value);
        }  catch(Exception e) {
            FormattingTuple  message = MessageFormatter.format(&quot;属性[{}]注入失败&quot;, field);
            throw new Configuartion
        }
    }

}
</code></pre>
<p>缓存服务器哦管理器工厂</p>
<pre><code class="java">public class ServiceManagerFacotory implements FactoryBean&lt;ServiceManager&gt; {

    public static final String ENTITY_CLASSES_NAME = &quot;entityClasses&quot;;
    public static final String PERSISTER_CONFIG_NAME = &quot;persusterConfig&quot;;

    private Accessor accessor;
    private Querier querier;
    private Set&lt;Class&lt;AbstractEntity&gt;&gt; entityClasses;
    private Map&lt;String, PersisterConfig&gt; persisterConfig;
    private Map&lt;String, Integer&gt; constants;

    private ServiceManaget cacheServiceManager;

    @Overide
    public ServiceManager getObeject() throws Exception {
        cacheServiceManager = new SeriviceManager(entityClassess, accessor, querier, 
        constants, persisterConfig);
        return cacheServiceManager;
    }

    @PreDestroy
    public void shutdown() {
        if(cacheServiceManger == null) {
            return;
        }
        cacheServiceManager.shutdown();
    }

    // Sertter Methods ....

    @Override
    public Class&lt;?&gt; getObejectType() {
        return SeriviceManager.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

}

</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存持久化系统基于Spring和Hibernate。</p>
<ol>
<li>通过配置文件注入实现了<code>HibernateDaoSupport</code>的<code>Accessor</code>(负责数据更新)和<code>Querier</code>(负责数据查询)的实现类。</li>
<li><p>Spring启动加载bean时，读取有<code>Cache</code>注解标识的路径，转化其为<code>Class&lt;? extends AbstractEntity&gt;</code>类对象，将它们加入<code>ServiceManagerFactory</code>的<code>BeanDefinitionBuilder</code>中。</p>
<pre><code class="java">         // 创建工厂类定义
     BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceFactory.class);

     // 设置存储器
     builder.addPropertyReference(ElementNames.ACCESSOR, getAccessorBeanName(element));
     // 设置查询器
     builder.addPropertyReference(ElementName.QUERIER, getQuerierBeanName(element));
     builder.addPropertyValue(ServiceManagerFactory.ENTITY_CLASSES_NAME, classes);

</code></pre>
</li>
<li><p><code>ServicManager</code>管理着所有的<code></code>ServicManager<code>实现类实例。</code>ServiceManagerFactory<code>会完成对</code>ServicManager<code>的初始化（装配</code>Accessor<code>和</code>Querier`、Class<abstractentit>集合、常量、配置）。</abstractentit></p>
</li>
<li><p><code>InjectProcessor</code>会负责完成<code>@Inject</code>声明的<code>CacheSerivice</code>资源的注入工作。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="http://gonefuture.top/2019/11/13/项目笔记/缓存持久化系统学习/" data-id="ck8gr4ztc005p1ovtbh94ildo" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>

<!--PC和WAP自适应版-->
<div id="SOHUCS" sid="项目笔记/缓存持久化系统学习" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cytLwvbWT'; 
var conf = 'prod_c2be45ba4993cf83be33cabf34204da1'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/03/项目笔记/属性系统学习笔记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/10/31/项目笔记/通讯组件学习/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>




</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/25/游戏框架笔记/技能系统设计/">技能系统设计</a>
          </li>
        
          <li>
            <a href="/2020/03/24/游戏框架笔记/跨服系统设计/">跨服系统的设计</a>
          </li>
        
          <li>
            <a href="/2020/03/23/游戏框架笔记/合服组件的设计/">合服组件的设计</a>
          </li>
        
          <li>
            <a href="/2020/01/03/项目笔记/属性系统学习笔记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/11/13/项目笔记/缓存持久化系统学习/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/expression/">expression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">30</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏开发/">游戏开发</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">36</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="450" src="//music.163.com/outchain/player?type=0&id=472116048&auto=1&height=430"></iframe>
  </div>




  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 WeiJian Qian
	  <span id="busuanzi_container_site_pv">
		 <span id="busuanzi_value_site_pv"></span>hits
    </span><br>
    <a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备17094722号-1</a> 

      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">categories</a>
  
    <a href="/tags" class="mobile-nav-link">tags</a>
  
    <a href="/about" class="mobile-nav-link">about</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script> -->
<script src="//db101.cn/file/js/jquery.min.js"></script>
<script src="//db101.cn/file/js/jquery.qrcode.min.js">
<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script> -->


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>

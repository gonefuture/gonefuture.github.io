
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>零碎的知识点-5 | gonefuture</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="零碎的知识点-5 AOP的实现方式AOP是Aspect Oriented Programming的缩写，意思是面向方面编程。 Java可以通过三个层面来实现AOP：  在编译期修改源代码 在运行期字节码加载前修改字节码 0 在运行期字节码加载后动态创建代理类的字节码  各种实现机制的比较：   类别 机制 原理 优点 缺点 实现的代表     静态AOP 静态织入 在编译期，切面直接以字节码的形式">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="零碎的知识点-5">
<meta property="og:url" content="http://gonefuture.top/2018/08/28/零碎的知识点-5/index.html">
<meta property="og:site_name" content="gonefuture">
<meta property="og:description" content="零碎的知识点-5 AOP的实现方式AOP是Aspect Oriented Programming的缩写，意思是面向方面编程。 Java可以通过三个层面来实现AOP：  在编译期修改源代码 在运行期字节码加载前修改字节码 0 在运行期字节码加载后动态创建代理类的字节码  各种实现机制的比较：   类别 机制 原理 优点 缺点 实现的代表     静态AOP 静态织入 在编译期，切面直接以字节码的形式">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-08-28T09:42:14.283Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="零碎的知识点-5">
<meta name="twitter:description" content="零碎的知识点-5 AOP的实现方式AOP是Aspect Oriented Programming的缩写，意思是面向方面编程。 Java可以通过三个层面来实现AOP：  在编译期修改源代码 在运行期字节码加载前修改字节码 0 在运行期字节码加载后动态创建代理类的字节码  各种实现机制的比较：   类别 机制 原理 优点 缺点 实现的代表     静态AOP 静态织入 在编译期，切面直接以字节码的形式">
  
    <link rel="alternative" href="/atom.xml" title="gonefuture" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/gonefutre"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">钱伟健的个人博客</a>
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">gonefuture</li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/categories">categories</a>
      
        <a class="main-nav-link" href="/tags">tags</a>
      
        <a class="main-nav-link" href="/about">about</a>
      
      <a class="main-nav-link st-search-show-outputs">Search</a>
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-零碎的知识点-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2018/08/28/零碎的知识点-5/" class="article-date">
  <time datetime="2018-08-28T09:41:44.741Z" itemprop="datePublished">2018-08-28</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/零碎的知识点/">零碎的知识点</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      零碎的知识点-5
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h1 id="零碎的知识点-5"><a href="#零碎的知识点-5" class="headerlink" title="零碎的知识点-5"></a>零碎的知识点-5</h1><hr>
<h2 id="AOP的实现方式"><a href="#AOP的实现方式" class="headerlink" title="AOP的实现方式"></a>AOP的实现方式</h2><p>AOP是Aspect Oriented Programming的缩写，意思是面向方面编程。</p>
<p>Java可以通过三个层面来实现AOP：</p>
<ol>
<li>在编译期修改源代码</li>
<li>在运行期字节码加载前修改字节码 0</li>
<li>在运行期字节码加载后动态创建代理类的字节码</li>
</ol>
<h3 id="各种实现机制的比较："><a href="#各种实现机制的比较：" class="headerlink" title="各种实现机制的比较："></a>各种实现机制的比较：</h3><table>
<thead>
<tr>
<th>类别</th>
<th>机制</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
<th>实现的代表</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态AOP</td>
<td>静态织入</td>
<td>在编译期，切面直接以字节码的形式编译到目标字节码文件中</td>
<td>对系统无性能影响</td>
<td>灵活性不够</td>
<td>AspectJ</td>
</tr>
<tr>
<td>动态AOP</td>
<td>动态代理</td>
<td>在运行期，目标类加载后，为接口动态生成代理类，将切面织入到代理类中</td>
<td>相对于静态AOP更加灵活</td>
<td>切入的关注点需要实现接口。对系统有一点性能影响</td>
<td>JDK动态代理，Spring</td>
</tr>
<tr>
<td>动态字节码生成</td>
<td>CGLIB</td>
<td>在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中    没有接口也可以织入    扩展类的实例方法为final时，则无法进行织入</td>
<td></td>
<td>CGLIB,Spring</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td></td>
<td>在运行期，目标加载前，将切面逻辑加到目标字节码里</td>
<td>可以对绝大部分类进行织入</td>
<td>代码中如果使用了其他类加载器，则这些类将不会被织入</td>
<td></td>
</tr>
<tr>
<td>字节码转换</td>
<td></td>
<td>在运行期，所有类加载器加载字节码前进行拦截</td>
<td>可以对所有类进行织入</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="AOP里的成员："><a href="#AOP里的成员：" class="headerlink" title="AOP里的成员："></a>AOP里的成员：</h3><ul>
<li>Joinpoint：拦截点，如某个业务方法</li>
<li>Pointcut：Joinpoint的表达式，表示拦截哪些方法。一个Pointcut对应多个Joinpoint</li>
<li>Advice：要切入的逻辑</li>
<li>Before Advice：在方法前切入</li>
<li>After Advice：在方法后切入，抛出异常则不会切入</li>
<li>After Returning Advice：在方法返回后切入，抛出异常则不会切入</li>
<li>After Throwing Advice：在方法抛出异常时切入</li>
<li>Around Advice：在方法执行前后切入，可以中断或忽略原有流程的执行</li>
</ul>
<h3 id="AOP实现的功能"><a href="#AOP实现的功能" class="headerlink" title="AOP实现的功能"></a>AOP实现的功能</h3><ul>
<li>性能监控：在方法调用前后记录调用时间，方法执行太长或超时报警</li>
<li>缓存代理：缓存某方法的返回值，下次执行该方法时，直接从缓存里获取</li>
<li>软件破解：使用AOP修改软件的验证类的判断逻辑<br>记录日志：在方法执行前后记录系统日志</li>
<li>工作流系统：工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务</li>
<li>权限验证：方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉</li>
</ul>
<h3 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h3><p>Spring默认采取动态代理机制实现AOP，当动态代理不可用时（代理类无接口）会使用cglib机制</p>
<p>但Spring的AOP有一定的缺点：</p>
<ul>
<li>第一，只能对方法进行切入，不能对接口、字段、静态代码块进行切入（切入接口的某个方法，则该接口下所有实现类的该方法都将被切入）</li>
<li>第二，同类中的互相调用方法将不会使用代理类。因为要使用代理类必须从Spring容器中获取Bean</li>
<li>第三，性能不是最好的。从前面几节得知，我们自定义的类加载器，性能优于动态代理和cglib</li>
</ul>
<hr>
<h2 id="用双向链表实现一个栈"><a href="#用双向链表实现一个栈" class="headerlink" title="用双向链表实现一个栈"></a>用双向链表实现一个栈</h2><p>java里默认的LinkedList很适合包装成栈，因为栈不需要随机访问。</p>
<pre><code class="java">public class DLStack implements Stack&lt;Integer&gt; {

    private LinkedList&lt;Integer&gt; storage = new LinkedList&lt;&gt;();


    /**
     * 压出元素
     *
     * @param v 元素
     */
    @Override
    public void push(Integer v) {
        storage.addFirst(v);
    }

    /**
     * 获取栈顶元素，但并不将其从栈顶移除。
     *
     * @return 栈顶元素
     */
    @Override
    public Integer peek() {
        return storage.getFirst();
    }

    /**
     * 移除并返回栈顶元素
     *
     * @return 栈顶元素
     */
    @Override
    public Integer pop() {
        return storage.removeFirst();
    }

    /**
     * 判断栈是否为空
     *
     * @return 是否为空
     */
    @Override
    public boolean empty() {
        return storage.isEmpty();
    }

    /**
     * 获取栈的大小
     *
     * @return 栈的大小
     */
    @Override
    public long size() {
        return storage.size();
    }

   public String toString(){
        return storage.toString();
    }
}

</code></pre>
<hr>
<h2 id="countdownlatch和cyclicbarrier的作用和区别"><a href="#countdownlatch和cyclicbarrier的作用和区别" class="headerlink" title="countdownlatch和cyclicbarrier的作用和区别"></a>countdownlatch和cyclicbarrier的作用和区别</h2><h3 id="countdownlatch"><a href="#countdownlatch" class="headerlink" title="countdownlatch"></a>countdownlatch</h3><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<p>他是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行</p>
<h4 id="CountDownLatch的使用场景："><a href="#CountDownLatch的使用场景：" class="headerlink" title="CountDownLatch的使用场景："></a>CountDownLatch的使用场景：</h4><p>在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。 这个时候就可以使用CountDownLatch。CountDownLatch最重要的方法是countDown()和await()，前者主要是倒数一次，后者是等待倒数到0，如果没有到达0，就只有阻塞等待了。</p>
<blockquote>
<p>总结：CountDownLatch实质上就是一个AQS计数器，通过AQS来实现线程的等待与唤醒。</p>
</blockquote>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier，让一组线程到达一个同步点后再一起继续运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。</p>
<p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<h4 id="CyclicBarrier-使用场景："><a href="#CyclicBarrier-使用场景：" class="headerlink" title="CyclicBarrier 使用场景："></a>CyclicBarrier 使用场景：</h4><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。</p>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ol>
<li>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</li>
<li>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</li>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。<br>4, CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。</li>
</ol>
<hr>
<h2 id="Spring-IOC循环依赖解决方案"><a href="#Spring-IOC循环依赖解决方案" class="headerlink" title="Spring IOC循环依赖解决方案"></a>Spring IOC循环依赖解决方案</h2><blockquote>
<p>循环依赖就是N个类中循环嵌套引用，也就是两个或者两个以上的bean互相持有对方，最终形成闭环。如果在日常开发中我们用new 对象的方式发生这种循环依赖的话程序会在运行时一直循环调用，直至内存溢出报错。下面说一下Spring是如果解决循环依赖的。</p>
</blockquote>
<p>Spring为了解决单例的循环依赖问题，使用了三级缓存。</p>
<ul>
<li>singletonFactories ： 单例对象工厂的cache </li>
<li>earlySingletonObjects ：提前暴光的单例对象的Cache </li>
<li>singletonObjects：单例对象的cache</li>
</ul>
<pre><code class="java">/** Cache of singleton objects: bean name --&gt; bean instance */
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);

/** Cache of singleton factories: bean name --&gt; ObjectFactory */
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);

/** Cache of early singleton objects: bean name --&gt; bean instance */
private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);
</code></pre>
<p>所以，Spring容器循环依赖包括： 构造器循环依赖和setter循环依赖。</p>
<h3 id="构造器参数循环依赖"><a href="#构造器参数循环依赖" class="headerlink" title="构造器参数循环依赖"></a>构造器参数循环依赖</h3><p>通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖 </p>
<p>原理：Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符创建过程中将一直保持在这个池中，因为如果在创建bean过程中发现自己已经在“当前创建bean池”中时，将会抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖；而对于创建完毕的bean将从“当前创建bean池”中清除掉。</p>
<h3 id="setter方式单例，默认方式"><a href="#setter方式单例，默认方式" class="headerlink" title="setter方式单例，默认方式"></a>setter方式单例，默认方式</h3><p>Spring的单例对象的初始化主要分为三步： </p>
<pre><code class="flow">st=&gt;operation: createBeanInstance实例化
op1=&gt;operation: populateBean填充属性
op2=&gt;operation: InitializeBean初始化
st-&gt;op1-&gt;op2
</code></pre>
<ol>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</li>
<li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</li>
<li>initializeBean：调用spring xml等配置文件中的init 方法。</li>
</ol>
<p><strong>Spring是先将Bean对象实例化之后再设置对象属性的</strong></p>
<p>原理：对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（比如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖。</p>
<p>通过提前暴露一个单例工厂方法，从而使其他bean能引用到该<code>bean addSingletonFactory()</code>方法。Spring先是用构造实例化Bean对象 ，此时Spring会将这个实例化结束的对象放到一个Map中，并且Spring提供了获取这个未设置属性的实例化对象引用的方法。   结合我们的实例来看，，当Spring实例化了StudentA、StudentB、StudentC后，紧接着会去设置对象的属性，此时StudentA依赖StudentB，就会去Map中取出存在里面的单例StudentB对象，以此类推，不会出来循环的问题喽、</p>
<h3 id="setter方式原型，prototype"><a href="#setter方式原型，prototype" class="headerlink" title="setter方式原型，prototype"></a>setter方式原型，prototype</h3><ol>
<li><p>对于scope为<code>prototype</code>范围的bean，Spring容器无法完成依赖注入，因为Spring容器不进行缓存<code>prototype</code>作用域的bean，因此无法提前暴露一个创建中的bean，所以检测到循环依赖会直接抛出<code>BeanCurrentlyInCreationException</code>异常</p>
</li>
<li><p>对于单例作用域的bean，可以通过<code>setAllowCircularReferences(false)</code>来禁用循环引用，这样如果存在循环引用就会抛出异常来通知用户。</p>
</li>
</ol>
<hr>
<h2 id="利用classloader实现热部署"><a href="#利用classloader实现热部署" class="headerlink" title="利用classloader实现热部署"></a>利用classloader实现热部署</h2><p>对于Java应用程序来说，热部署就是在运行时更新Java类文件。</p>
<p>为了实现热部署，可以自定义类加载器，并重写ClassLoader的findClass方法。想要实现热部署可以分以下三个步骤：<br>1、销毁该自定义ClassLoader<br>2、更新class类文件<br>3、创建新的ClassLoader去加载更新后的class类文件。</p>
<hr>
<h2 id="热部署与热加载"><a href="#热部署与热加载" class="headerlink" title="热部署与热加载"></a>热部署与热加载</h2><h3 id="Java热部署与热加载的联系"><a href="#Java热部署与热加载的联系" class="headerlink" title="Java热部署与热加载的联系:"></a>Java热部署与热加载的联系:</h3><ol>
<li>不重启服务器编译/部署项目</li>
<li>基于Java的类加载器实现</li>
</ol>
<h3 id="Java热部署与热加载的区别"><a href="#Java热部署与热加载的区别" class="headerlink" title="Java热部署与热加载的区别:"></a>Java热部署与热加载的区别:</h3><p>部署方式:</p>
<ul>
<li>热部署在服务器运行时重新部署项目</li>
<li>热加载在运行时重新加载class</li>
</ul>
<p>实现原理 ：</p>
<ul>
<li>热部署直接重新加载整个应用</li>
<li>热加载在运行时重新加载class</li>
</ul>
<p>使用场景:</p>
<ul>
<li>热部署更多的是在生产环境使用</li>
<li>热加载则更多的实在开发环境使用</li>
</ul>
<hr>
<p>##Tomcat热部署机制</p>
<p>Tomcat的容器实现热部署使用了两种机制：</p>
<ol>
<li>Classloader重写，通过自定义classloader加载相应的jsp编译后的class到JVM中。 通过动态修改内存中的字节码，将修改过的class再次装载到JVM中。</li>
</ol>
<p>Tomcat通过<code>org.apache.jasper.servlet.JasperLoader</code>实现了对jsp的加载。</p>
<ol start="2">
<li>通过代理修改内存中class的字节码</li>
</ol>
<p>Tomcat中的class文件是通过<code>org.apache.catalina.loader. WebappClassLoader</code>装载的。在热部署的情况下，对于被该classloader 加载的class文件，它的classloader始终是同一个WebappClassLoader，除非容器重启了。</p>
<h2 id="HashMap的一些知识点："><a href="#HashMap的一些知识点：" class="headerlink" title="HashMap的一些知识点："></a>HashMap的一些知识点：</h2><h3 id="如何处理null"><a href="#如何处理null" class="headerlink" title="如何处理null"></a>如何处理null</h3><p>当key为null时，HashMap执行<code>putForNullKey()</code>方法。在方法里有个for循环，是在talbe[0]链表中查找key为null的元素，如果找到，则将value重新赋值给这个元素的value，并返回原来的value。<br>如果上面for循环没找到则将这个元素添加到<strong><code>talbe[0]</code></strong>链表的表头。</p>
<h3 id="HashMap在JDK1-7与JDK1-8的区别"><a href="#HashMap在JDK1-7与JDK1-8的区别" class="headerlink" title="HashMap在JDK1.7与JDK1.8的区别"></a>HashMap在JDK1.7与JDK1.8的区别</h3><h4 id="JDK1-7中"><a href="#JDK1-7中" class="headerlink" title="JDK1.7中"></a>JDK1.7中</h4><p>使用一个Entry数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同（hash collision），那么这些key会被定位到Entry数组的同一个桶里，这些key会形成一个链表。</p>
<p>在hashcode特别差的情况下，比方说所有key的hashcode都相同，这个链表可能会很长，那么put/get操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到O(n)</p>
<h4 id="DK1-8中"><a href="#DK1-8中" class="headerlink" title="DK1.8中"></a>DK1.8中</h4><p>使用一个Node数组来存储数据，但这个Node可能是链表结构，也可能是红黑树结构。如果插入的key的hashcode相同，那么这些key也会被定位到Node数组的同一个桶里。如果同一个桶里的key不超过<strong>8</strong>个，使用链表结构存储。如果超过了<strong>8</strong>个，那么会调用treeifyBin函数，将链表转换为红黑树。那么即使hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销，也就是说put/get的操作的时间复杂度最差只有O(log n)。</p>
<p> 但是真正想要利用JDK1.8的好处，有一个限制：key的对象，必须正确的实现了Compare接口。如果没有实现Compare接口，或者实现得不正确（比方说所有Compare方法都返回0），那JDK1.8的HashMap其实还是慢于JDK1.7的。</p>
<h3 id="解决hash冲突的办法"><a href="#解决hash冲突的办法" class="headerlink" title="解决hash冲突的办法"></a>解决hash冲突的办法</h3><ol>
<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立一个公共溢出区</li>
</ol>
<p>Java中hashmap的解决办法就是采用的链地址法。</p>
<hr>
<h2 id="B树与B-树简要区别"><a href="#B树与B-树简要区别" class="headerlink" title="B树与B+树简要区别"></a>B树与B+树简要区别</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>每个节点都储存key和data，所有节点组成这棵树，并且叶子节点指针为null。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>只有叶子节点存储data，叶子节点包含这棵树的所有键值，字节节点不储存指针。<br>  后来，在B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的首选数据结构。 </p>
<p>因为B+树内节点不存储data，这样一个节点就可以存储更多的key，更适合做数据库的索引。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>  data存的是数据地址。索引是索引，数据是数据。</p>
<p>InnoDB</p>
<p>  data存的是数据本身。索引也是数据。</p>
<hr>
<h2 id="MyISAM和InnoDB的主要区别和应用场景"><a href="#MyISAM和InnoDB的主要区别和应用场景" class="headerlink" title="MyISAM和InnoDB的主要区别和应用场景"></a>MyISAM和InnoDB的主要区别和应用场景</h2><p>主要区别：</p>
<ol>
<li>MyISAM是非事务安全型的，而InnoDB是<strong>事务安全型</strong>的。</li>
<li>MyISAM锁的粒度是表级，而InnoDB支持<strong>行级</strong>锁定。</li>
<li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。(MySQL 5.7开始支持全文索引)</li>
<li>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li>
<li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li>
<li>InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li>
<li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li>
</ol>
<hr>
<h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><h3 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h3><p>依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据，比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。</p>
<h3 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h3><p>依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理</p>
<h3 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h3><ol>
<li>拦截器<code>interceptor</code>是基于Java的<strong>反射机制</strong>的，而过滤器Filter是基于函数回调,实现的filter接口中doFilter方法就是回调函数。</li>
<li>拦截器interceptor不依赖与servlet容器，过滤器Filter依赖与servlet容器,没有servlet容器就无法来回调<code>doFilter</code>方法。</li>
<li>拦截器interceptor只能对action请求起作用，而过滤器Filter则可以对几乎所有的请求起作用,Filter的过滤范围比Interceptor大,Filter除了过滤请求外通过通配符可以保护页面，图片，文件等等。</li>
<li>拦截器interceptor可以访问action上下文、值栈里的对象，而过滤器Filter不能访问。</li>
<li>在action的生命周期中，拦截器interceptor可以多次被调用，而过滤器Filter只能在容器初始化时被调用一次。</li>
<li>拦截器interceptor可以获取IOC容器中的各个bean，而过滤器Filter就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li>
</ol>
<hr>
<h2 id="CMS收集器和G1收集器优缺点与区别"><a href="#CMS收集器和G1收集器优缺点与区别" class="headerlink" title="CMS收集器和G1收集器优缺点与区别"></a>CMS收集器和G1收集器优缺点与区别</h2><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，CMS收集器是基于“”标记–清理”算法实现的，整个过程分为四个步骤： </p>
<ol>
<li>初始标记 </li>
<li>并发标记 </li>
<li>重新标记  </li>
<li>并发清理 </li>
</ol>
<p>优点：并发收集，低停顿 </p>
<p>缺点： </p>
<ol>
<li>CMS收集器对CPU资源非常敏感 <ol start="2">
<li>CMS处理器无法处理浮动垃圾(即标记过程产生的垃圾) </li>
<li>CMS是基于“标记–清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。</li>
</ol>
</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>Java8之后广泛使用，G1 将整个对区域划分为若干个<strong>Region</strong>，每个Region的大小是2的倍数（1M,2M,4M,8M,16M,32M，通过设置堆的大小和Region数量计算得出。<br>Region区域划分与其他收集类似，不同的是单独将大对象分配到了单独的region中，会分配一组连续的Region区域（Humongous start 和 humonous Contoinue 组成），所以一共有四类Region（Eden，Survior，<strong>Humongous</strong>和Old），<br>G1 作用于整个堆内存区域，设计的目的就是减少Full GC的产生。在Full GC过程中由于G1 是单线程进行，会产生较长时间的停顿。<br>G1的OldGc标记过程可以和yongGc并行执行，但是OldGc一定在YongGc之后执行，即MixedGc在yongGC之后执行。</p>
<p>名词解释(JDK1.8)：</p>
<ul>
<li>MetaSpace<br>  在Java8之后取代永久代方法区的内存部分，NativeMemory</li>
<li>Mixed GC Event<br>  所有Young Region和一部分Old Region的混合GC时间。</li>
<li>Reclaimable<br>  G1 为了能够回收，创建了一系列专门用于对象回收的Region，存放在链表中，只包含存活率小于-XX:G1MixedGCLIveThresholdPercent(默认是85%)的region, region的值除以整个Java堆区，如果大于-XX:G1HeapWastePercent(默认5%)，则启动回收机制</li>
<li>Minor GC<br>年轻代GC</li>
<li>Major GC(Full GC)<br>发生在老年代的GC</li>
</ul>
<p>G1是一款面向服务端应用的垃圾收集器。G1具备如下特点：</p>
<ol>
<li>并行于并发</li>
<li>分代收集</li>
<li>空间整合（，G1从整体来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。）</li>
<li>可预测的停顿</li>
</ol>
<p>G1运行步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
<p>G1相对于CMS的主要区别在：</p>
<ol>
<li>G1在压缩空间方面有优势</li>
<li>G1通过将内存空间分成区域（Region）的方式避免内存碎片问题</li>
<li>Eden, Survivor, Old区<strong>不再固定</strong>、在内存使用效率上来说更灵活</li>
<li>G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象</li>
<li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做</li>
<li>G1会在Young GC中使用、而CMS只能在O区使用</li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

        <a data-url="http://gonefuture.top/2018/08/28/零碎的知识点-5/" data-id="cjm0cropu002ts0vtztramz0w" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>

<!--PC和WAP自适应版-->
<div id="SOHUCS" sid="零碎的知识点-5" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cytLwvbWT'; 
var conf = 'prod_c2be45ba4993cf83be33cabf34204da1'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/28/零碎的知识点-6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          零碎的知识点-6
        
      </div>
    </a>
  
  
    <a href="/2018/08/28/《Java并发编程实战》-15/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《Java并发编程实战》-15   第16章 Java内存模型</div>
    </a>
  
</nav>

  
</article>




</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/12/《Netty实战》-第五章-ByteBuf/">《Netty实战》-第五章-ByteBuf</a>
          </li>
        
          <li>
            <a href="/2018/09/11/游戏开发-基于netty的文字冒险游戏-1/">游戏开发-基于netty的冒险游戏-1</a>
          </li>
        
          <li>
            <a href="/2018/08/28/零碎的知识点-6/">零碎的知识点-6</a>
          </li>
        
          <li>
            <a href="/2018/08/28/零碎的知识点-5/">零碎的知识点-5</a>
          </li>
        
          <li>
            <a href="/2018/08/28/《Java并发编程实战》-15/">《Java并发编程实战》-15   第16章 Java内存模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/expression/">expression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏开发/">游戏开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="450" src="//music.163.com/outchain/player?type=0&id=472116048&auto=1&height=430"></iframe>
  </div>




  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 WeiJian Qian
	  <span id="busuanzi_container_site_pv">
		 <span id="busuanzi_value_site_pv"></span>hits
    </span><br>
    <a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备17094722号-1</a> 

      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">categories</a>
  
    <a href="/tags" class="mobile-nav-link">tags</a>
  
    <a href="/about" class="mobile-nav-link">about</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script> -->
<script src="//db101.cn/file/js/jquery.min.js"></script>
<script src="//db101.cn/file/js/jquery.qrcode.min.js">
<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script> -->


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
